# MongoDB Learning Platform Project Queries (Task 1.1 - Task 6.2)


# Task 1.1 - Create Collections with JSON Schema
from pymongo import MongoClient
from datetime import datetime, timedelta
import pandas as pd


# establish connection
client = MongoClient('mongodb://localhost:27017') 

# creating database
db = client['eduhub_db']
#creating colllection
db.create_collection("users_collection", validator={"$jsonSchema": { ... }})
db.create_collection("courses_collection", validator={"$jsonSchema": { ... }})
db.create_collection("enrollment_collection", validator={"$jsonSchema": { ... }})
db.create_collection("lesson", validator={"$jsonSchema": { ... }})
db.create_collection("assignment", validator={"$jsonSchema": { ... }})
db.create_collection("submission", validator={"$jsonSchema": { ... }})

#task1.2 - create schema documents
user_schema = {
  "id": "ObjectId (auto-generated )",
  "userId": "String (unique)",
  "email": "String (unique, required)",
  "firstName": "String (required)",
  "lastName": "String (required)",
  "role": "String (enum: ['student', 'instructor'])",
  "dateJoined": "DateTime",
  "profile": {
    "bio": "String",
    "avatar": "String",
    "skills": ["String"] 
  },
 "isActive": "Boolean"
}

course_schema= {
  "_id": "ObjectId (auto-generated )",
  "courseId": "String (unique, required)",
  "title": "String (required)",
  "description": "String (optional)",
  "instructorId": "String (reference to users, required)",
  "category": "String (optional)",
  "level": "String (enum: ['beginner', 'intermediate', 'advanced'])",
  "duration": "Number (in hours, optional)",
  "price": "Number",
  "tags": ["String"], 
  "createdAt": "DateTime (auto-generated)",
  "updatedAt": "DateTime (auto-updated)",
  "isPublished": "Boolean (default: false)"
}
  
enrollment_schema= {
  "_id": "ObjectId (auto-generated by MongoDB)",
  "enrollmentId": "String (unique, required)",
  "studentId": "String (reference to users, required)",
  "courseId": "String (reference to courses, required)",
  "enrolledAt": "DateTime (auto-generated)",
  "status": "String (enum: ['active', 'completed', 'dropped'], default: 'active')",
  "progress": "Number (percentage of course completed, default: 0)"
}
 
lesson_schema ={
  "_id": "ObjectId (auto-generated by MongoDB)",
  "lessonId": "String (unique, required)",
  "courseId": "String (required, reference to courses)",
  "title": "String (required)",
  "content": "String (HTML, text, or markdown)",
  "videoUrl": "String (optional, video link)",
  "resources": ["String (optional links to files, docs, etc.)"],
  "order": "Number (position in course, e.g., 1, 2, 3)",
  "duration": "Number (optional, estimated time in minutes)",
  "isPublished": "Boolean (default: false)",
  "createdAt": "DateTime (auto-generated)",
  "updatedAt": "DateTime (auto-updated)"
}

assignment_schema = {
    "_id": "ObjectId (auto-generated)",
    "courseId": "string (reference to courses)",
    "assignmentId": "string (unique)",
    "lessonId": "string (optional reference to lessons)",
    "title": "string (required)",
    "description": "string",
    "totalPoints": "number",
    "givenDate": "datetime",                          # NEW: When assignment was given
    "dueDate": "datetime",
    "instructorName": "string",                       # NEW: Name of the instructor
    "attachments": ["string"],
    "isPublished": "boolean",
    "createdAt": "datetime",
    "updatedAt": "datetime"
}

submission_schema = {
     "_id": "ObjectId (auto-generated)",
    "submissionId": "string (unique)",                   # Unique submission ID
    "assignmentId": "string (reference to assignments)", # Which assignment this is for
    "studentId": "string (reference to users)",          # Who submitted it
    "submittedAt": "datetime",                           # Time of submission
    "content": "string",                                 # Optional: written answer
    "fileUrl": "string",                                 # Optional: link to uploaded file
    "score": "number",                                   # Points awarded
    "feedback": "string",                                # Instructor's comment
    "gradedBy": "string (instructor name)",              # Who graded it
    "isLate": "boolean",                                 # Was it submitted after due date?
    "gradeDate": "datetime"                  
}


# Task 2.1 - Insert Sample Data
# Users
from faker import Faker
import random
import uuid
fake = Faker()

users_collection = db["users_collection"] # to define users collection

#20 users (mix of students and instructors)
users = []

for _ in range(20):
    user = {
        "userId": str(uuid.uuid4()),
        "email": fake.unique.email(),
        "firstName": fake.first_name(),
        "lastName": fake.last_name(),
        "role": random.choice(["student", "instructor"]),
        "dateJoined": fake.date_time_this_year(),
        "profile": {
            "bio": fake.sentence(),
            "avatar": fake.image_url(),
            "skills": [fake.job() for _ in range(random.randint(1, 3))]
            },
        
        "isActive": random.choice([True, False])
        
    }
    users.append(user)


# Insert  many users into users_collection
def insert_user(users):
    try:
        response = users_collection.insert_many(users)
        return response
    except Exception as e:
        print(f"Error finding document:{e}")
        return None
result = insert_user(users)
print(result)


# Courses
course_collection = db["course_collection"] # to define course collection

# 8 courses across different categories


instructor_ids = [user["userId"] for user in users if user["role"] == "instructor"]

categories = ["Programming", "Design", "Business", "Data Science", "Marketing", "Finance"]
levels = ["beginner", "intermediate", "advanced"]

courses = []
for i in range(8):
    course = {
        "courseId": f"course_{i+1}",
        "title": fake.sentence(nb_words=4).replace(".", ""),
        "description": fake.paragraph(),
        "instructorId": random.choice(instructor_ids),
        "category": random.choice(categories),
        "level": random.choice(levels),
        "duration": round(random.uniform(1.0, 10.0), 1),
        "price": round(random.uniform(0, 200), 2),
        "tags": fake.words(nb=random.randint(2, 4)),
        "createdAt": fake.date_time_between(start_date='-1y', end_date='-6mo'),
        "updatedAt": fake.date_time_between(start_date='-6mo', end_date='now'),
        "isPublished": random.choice([True, False])
    }
    courses.append(course)
    
# Insert into courses into course_collection
def insert_courses(courses):
    try:
        response = course_collection.insert_many(courses)
        return response
    except Exception as e:
        print(f"Error finding document:{e}")
        return None

result = insert_courses(courses)
print(result)

# Enrollments

enrollment_collection = db["enrollment_collection"] # to define the  enrollment collection

import random


## 15 enrollments



students = list(db.users_collection.find({"role": "student"})) 
courses = list(db.course_collection.find({})) 

enrollments = []

statuses = ['active', 'completed', 'dropped']
if not students or not courses:
    print(" Cannot create enrollments: No students or courses found.")
    print("Number of students found:", len(students))
    print("Number of courses found:", len(courses))
    exit() 

for i in range(15):
    student = random.choice(students)
    course = random.choice(courses)

    enrollment = {
        "enrollmentId": f"ENR{i+1:03}",
        "studentId": student["userId"],
        "courseId": course["courseId"],
        "enrollmentAt": fake.date_time_between(start_date="-3M", end_date="now"),
        "progress": round(random.uniform(0, 100), 2),
        
        "status": random.choice(statuses)
    }

    enrollments.append(enrollment)
    

# Insert  enrollments into enrollment_collection
def insert_enrollment(enrollments):
    try:
        response = enrollment_collection.insert_many(enrollments)
        return response
    except Exception as e:
        print(f"Error finding document:{e}")
        return None

result = insert_enrollment(enrollments)
print(result)

# lesson
lesson_collection = db["lesson_collection"] # to define lesson collection

# 25 lessons

lessons = []
for i in range(25):
    course = random.choice(courses)  # assume `courses` list exists
    lessons.append({
        "lessonId": f"lesson_{i+1}",
        "courseId": course["courseId"],
        "title": fake.sentence(nb_words=6),
        "description": fake.paragraph(),
        "content": fake.text(max_nb_chars=300),
        "videoUrl": fake.url(),
        "resources": [fake.url() for _ in range(random.randint(1, 3))],
        "durationMinutes": random.randint(5, 30),
        "order": i + 1,
        "status": random.choice(["draft", "published", "archived"]),
        "isFreePreview": random.choice([True, False]),
        "createdAt": fake.date_time_between(start_date='-2y', end_date='-1y'),
        "updatedAt": fake.date_time_between(start_date='-1y', end_date='now')
    })
#to insert the lesson documents created into the lesson_collection  
def insert_lesson(lessons):
    try:
        response = lesson_collection.insert_many(lessons)
        return response
    except Exception as e:
        print(f"Error finding document:{e}")
        return None

result = insert_lesson(lessons)
print(result)

# Assignments
assignment_collection = db["assignment_collection"]  # to define assignment collection

# 10 assignments
users = list(db.users_collection.find({}, {"userId": 1, "role": 1}))
courses = list(db.course_collection.find({}, {"courseId": 1}))
lessons = list(db.lesson_collection.find({}, {"lessonId": 1, "courseId": 1}))

print("Courses:", len(courses))
print("Lessons:", len(lessons))
print("Users:", len(users))

if not users or not courses or not lessons:
    print(" Cannot generate assignments: missing users, courses, or lessons.")
else:
 assignments = []

 for i in range(10):
    course = random.choice(courses)
    matching_lessons = [l for l in lessons if l["courseId"] == course["courseId"]]
    instructors = [u for u in users if u["role"] == "instructor"]

    if not matching_lessons or not instructors:
        continue  # Skip this iteration if missing lesson or instructor

    lesson = random.choice(matching_lessons)
    instructor = random.choice(instructors)

    assignments.append({
    "assignmentId": f"assign_{i+1}",
    "courseId": course["courseId"],
    "lessonId": lesson["lessonId"],
    "instructorName": fake.name(),  # Replace instructorId with instructorName
    "title": fake.sentence(),
    "description": fake.paragraph(),
    "totalPoints": random.randint(50, 100),  # Rename maxScore → totalPoints
    "givenDate": fake.date_time_between(start_date='-6mo', end_date='now'),  # New required field
    "dueDate": fake.future_datetime(end_date='+30d'),
    "attachments": [],  # Required field — can start as empty list
    "isPublished": random.choice([True, False]),
    "createdAt": fake.date_time_between(start_date='-6mo', end_date='now'),
    "updatedAt": fake.date_time_between(start_date='-6mo', end_date='now')
})
#to insert the  assignment documents created into the asignment_collection
def insert_assignment(assignments):
    try:
        response = assignment_collection.insert_many(assignments)
        return response
    except Exception as e:
        print(f"Error finding document:{e}")
        return None

result = insert_assignment(assignments)
print(result)

# Submissions

submission_collection = db["submission_collection"] # to define submission collection

# 12 assignment submissions

submissions = []
for i in range(12):
    assignment = random.choice(assignments)
    student = random.choice([u for u in users if u["role"] == "student"])
    submitted_at = fake.date_time_between(start_date=assignment["givenDate"], end_date=assignment["dueDate"] + timedelta(days=5))
    
    submissions.append({
        "submissionId": f"sub_{i+1}",
        "assignmentId": assignment["assignmentId"],
        "studentId": student["userId"],
        "submittedAt": submitted_at,
        "content": fake.paragraph(nb_sentences=3),
        "fileUrl": fake.url(),
        "score": random.randint(0, assignment["totalPoints"]),
        "feedback": fake.sentence(nb_words=8),
        "gradedBy": assignment["instructorName"],
        "isLate": submitted_at > assignment["dueDate"],
        "gradeDate": fake.date_time_between(start_date=submitted_at, end_date='now')
    })
    # to insert the submission assignment documents created into the submission_collectio
def insert_submission(submissions):
    try:
        response = submission_collection.insert_many(submissions)
        return response
    except Exception as e:
        print(f"Error finding document:{e}")
        return None

result = insert_submission(submissions)
print(result)

# to insert many to my collections

users_collection.insert_many(users) # users = create   users of your choice 
course_collection.insert_many(courses) # courses = create  courses of ypur choice
enrollment_collection.insert_many(enrollments) # enrollments= create enrollments of your choice 
lesson_collection.insert_many(lessons) # lessons = create lessons of your choice 
assignment_collection.insert_many(assignments) #assignments = create assignments of your choice 
submission_collection.insert_many(submissions) #submissions = create usubmissions of your choice 

# Task 2.2 - Referential Integrity Checks

students = list(db.users_collection.find({"role": "student"}, {"userId": 1}))
instructors = list(db.users_collection.find({"role": "instructor"}, {"userId": 1}))
courses = list(db.courses_collection.find({}, {"courseId": 1}))
lessons = list(db.lesson.find({}, {"lessonId": 1, "courseId": 1}))


# Task 3.1 - Create Operations
# add a new student
def insert_user(add_student):
    try:
        result = users_collection.insert_one(add_student)
        return result
    except Exception as e:
        print(f"Error finding document:{e}")
        return None
#add_student should meet users_collection requirement
add_student = {
    "userId": str(uuid.uuid4()),
    "email": "lisa@gmail.com",
    "firstName": "lisa",
    "lastName": "aniebo",
    "role": "student",
    "dateJoined": datetime.now(),
    "profile": {
        "bio": "she is a female",
        "avatar": f"https://i.pravatar.cc/150?img={random.randint(1, 70)}",
        "skills": [fake.job() for _ in range(2)]
    },
    "isActive": random.choice([True, False])  
}
new_student = insert_user(add_student)

# Create a new course
def insert_course(add_new_course):
    try:
        result = course_collection.insert_one(add_new_course)
        

        return result
    except Exception as e:
        print(f"Error finding document:{e}")
        return None
instructor = users_collection.find_one({"role": "instructor"})
# create add_new_course to meet course_collection requirement
add_new_course ={
    "courseId": f"course_{str(uuid.uuid4())[:8]}",
    "title": "economy",
    "description": fake.paragraph(),
    "instructorId": instructor["userId"],
    "category": "business",
    "level": random.choice(["beginner", "intermediate", "advanced"]),
    "duration": round(random.uniform(2, 10), 1),
    "price": round(random.uniform(50, 200), 2),
    "tags": fake.words(nb=3),
    "createdAt": datetime.now(),
    "updatedAt": datetime.now(),
    "isPublished": True
}  
new_course = insert_course(add_new_course)   


# Enroll a student
#enroll new student
def insert_student_enrollment(new_enrollment):
    try:
        result = enrollment_collection.insert_one(new_enrollment)
        

        return result
    except Exception as e:
        print(f"Error finding document:{e}")
        return None
# define new_enrollment to meet enrollment_collection requirement 
new_enrollment = {
    "enrollmentId": f"ENR_{str(uuid.uuid4())[:8]}",
    "studentId": add_student["userId"], 
    "courseId": add_new_course["courseId"],
    "enrollmentAt": datetime.now(),
    "status": "active",
    "progress": 0
}    
new_student_enrollment = insert_student_enrollment(new_enrollment)

# Add a new lesson

lesson_collection = db["lesson_collection"]
#add new lesson
def insert_lesson(new_lesson):
    try:
        result = lesson_collection.insert_one(new_lesson)
        

        return result
    except Exception as e:
        print(f"Error finding document:{e}")
        return None
#new_leson should meet lesson collection requirement
new_lesson = {
    "lessonId": f"lesson_{str(uuid.uuid4())[:8]}",
    "courseId": add_new_course["courseId"],
    "title": fake.sentence(nb_words=8),
    "description": fake.paragraph(),
    "content": fake.text(max_nb_chars=200),
    "videoUrl": fake.url(),
    "resources": [fake.url() for _ in range(2)],
    "durationMinutes": random.randint(10, 30),
    "order": 1,
    "status": "published",
    "isFreePreview": False,
    "createdAt": datetime.now(),
    "updatedAt": datetime.now()
}  
add_new_lesson = insert_lesson(new_lesson)


# Task 3.2 - Read Operations

# Find active students
list(users_collection.find({"role":"student","isActive":True}))
def find_active_students(active=True):
    try:
        result = list(users_collection.find({
            "role": "student",
            "isActive": active
        }))
        return result
    except Exception as e:
        print(f"Error finding documents: {e}")
        return None
active_students = find_active_students()   
print(active_students)
len(active_students)

# Retrieve course + instructor info
course_details = list(db.course_collection.aggregate([
    {
        "$lookup": {
            "from": "users_collection",  # Match your actual users collection name
            "localField": "instructorId",
            "foreignField": "userId",
            "as": "instructorInfo"
        }
    },
    { "$unwind": "$instructorInfo" }
]))

for course in course_details:
    print(course)


# Courses in a category
def find_courses_by_category(category_name): 
    try:
        courses_in_category = list(course_collection.find({"category": category_name}))
        return courses_in_category
    except Exception as e:
        print(f"Error retrieving courses: {e}")
        return None

category_name = "Programming"  
result = find_courses_by_category(category_name)
print(result)


# Students enrolled in a course
course_collection = db.course_collection 


course_Id = "course_8"

# Step 1: Find enrollments for this course
enrollments = list(db.enrollment_collection.find({"courseId": course_Id}))
student_ids = [e["studentId"] for e in enrollments]
print("Student IDs found in enrollment:", student_ids)

# Step 2: Query users by userId
students = list(db.users_collection.find({"userId": {"$in": student_ids}}))
print(f"Matching users found: {len(students)}")

# Step 3: Print student names
print(f"\nStudents enrolled in course '{course_Id}':")
for student in students:
    full_name = f"{student.get('firstName', '')} {student.get('lastName', '')}".strip()
    print(full_name or "Name not found")

# Task 3.3 - Update Operations

# Update profile
#update a users profile information


def update_user_profile(user_id, new_bio, new_skills):
    try:
        result = users_collection.update_one(
            {"userId": user_id},
            {"$set": {
                "profile.bio": new_bio,
                "profile.skills": new_skills
            }}
        )
        return result
    except Exception as e:
        print(f"Error updating user profile: {e}")
        return None
#example
user_id = "febc251a-cd99-425b-8031-3c30ba1dfd3f" 
new_bio ="a male"
new_skills = ["python","SQL"]
updated_profile = update_user_profile(user_id, new_bio, new_skills)
if updated_profile:
    print("Documents updated:", updated_profile.modified_count)

# Publish course
#mark a course as published
course_collection = db.course_collection 
def publish_course(course_id):
    try:
        result = course_collection.update_one(
            {"courseId": course_id},
            {"$set": {"isPublished": True}}
        )
        return result
    except Exception as e:
        print(f"Error publishing course: {e}")
        return None

#example
course_id = "course_7"
published_course = publish_course(course_id)
print(published_course)


# Update assignment submission grade
#update  assignment grades

def update_assignment_grade(submission_id, new_score, feedback):
    try:
        result = submission_collection.update_one(
            {"submissionId": submission_id},
            {"$set": {
                "score": new_score,
                "feedback": feedback,
                "gradeDate": datetime.now()
            }}
        )
        return result
    except Exception as e:
        print(f"Error updating assignment grade: {e}")
        return None
  # example

submission_id = "sub_3"
new_score = 86
feedback = " well done!"
update =update_assignment_grade(submission_id, new_score, feedback)
print(update)
if update and update.modified_count:
    print(f"Updated submission {submission_id} successfully.")
else:
    print(f"No document was updated. Check if submission ID exists.")  


# Add tags to course
def add_course_tags(course_id, new_tags):
    try:
       
        course = course_collection.find_one({"courseId": course_id})
        if not course:
            print(f" No course found with courseId: '{course_id}'")
            return None
        
     
        result = course_collection.update_one(
            {"courseId": course_id},
            {"$addToSet": {"tags": {"$each": new_tags}}}
        )
        return result
    except Exception as e:
        print(f"Error adding tags to course: {e}")
        return None

course_id = "course_1"  # Make sure this is a perfect match
new_tags = ["the farmer"]
add = add_course_tags(course_id, new_tags)

print(add)
if add and add.modified_count:
    print(" Tags added successfully.")
else:
    print("No new tags were added (they may already exist or course not found).")



# Task 3.4 - Delete Operations

# Soft delete user
users_collection.update_one({"userId":uid}, {"$set":{"isActive":False}})
def soft_delete_user(user_id):
    try:
        result = users_collection.update_one(
            {"userId": user_id},
            {"$set": {"profile.isActive": False}}
        )
        return result
    except Exception as e:
        print(f"Error soft-deleting user: {e}")
        return None

# Example
user_id ="6dc1e62b-e92d-42cd-9e39-0d3d162d939b"
deleted = soft_delete_user(user_id)
print("Soft deleted:", deleted)


# Remove enrollment
enrollment_collection.delete_one({"enrollmentId":enrollment_id})

def delete_enrollment(enrollment_id):
    try:
        result = enrollment_collection.delete_one({"enrollmentId": enrollment_id})
        return result
    except Exception as e:
        print(f"Error deleting enrollment: {e}")
        return None

# Example
enrollment_id ="ENR002"
 
deleted = delete_enrollment(enrollment_id)
print("Enrollment deleted:", deleted)


# Remove lesson
lesson_collection.delete_one({"lessonId":lid})

def delete_lesson(lesson_id):
    try:
        result = lesson_collection.delete_one({"lessonId": lesson_id})
        return result
    except Exception as e:
        print(f"Error deleting lesson: {e}")
        return None

# Example 
lesson_id="lesson_5"
deleted = delete_lesson(lesson_id)
print("Lesson deleted:", deleted)


# Task 4.1 - Complex Queries


#find courses with price between $50 and $200
list(course_collection.find({"price":{"$gte":50,"$lte":200}}))
course_collection = db.course_collection
def find_courses_in_price_range(min_price, max_price):
    try:
        result = list(course_collection.find({
            "price": { "$gte": min_price, "$lte": max_price }
        }))
        return result
    except Exception as e:
        print(f"Error: {e}")
        return None

# Example
min_price = 50
max_price = 200
courses = find_courses_in_price_range(min_price,max_price)
print(f"Courses found: {len(courses)}")



#get users who joined in the last 6 months
six_months_ago = datetime.now() - timedelta(days=180)
list(users_collection.find({"dateJoined":{"$gte":six_months_ago}}))

users_collection= db.users_collection
def get_recent_users(months=6):
    try:
        cutoff_date = datetime.now() - timedelta(days=months*30)
        result = list(users_collection.find({
            "dateJoined": { "$gte": cutoff_date }
        }))
        return result
    except Exception as e:
        print(f"Error: {e}")
        return None

# Example
recent_users = get_recent_users()
print(f"Recent users: {len(recent_users)}")


#find courses that have specific  tags using $in operator
def find_courses_by_tags(tag_list):
    try:
        lowercased_tags = [tag.lower() for tag in tag_list]
        result = list(course_collection.find({
            "tags": {
                "$in": lowercased_tags
            }
        }))
        return result
    except Exception as e:
        print(f"Error: {e}")
        return []
tag_list = ["score","seven"]  # 
matching_courses = find_courses_by_tags(tag_list)
print(f"Courses found: {len(matching_courses)}")
for course in matching_courses:
    print(course["courseId"], "-", course["title"])

# Assignments due next week
assignment_collection = db.assignment_collection

def upcoming_assignments(days_ahead):
    try:
        now = datetime.now()
        upcoming = now + timedelta(days=days_ahead)
        result = list(assignment_collection.find({
            "dueDate": { "$gte": now, "$lte": upcoming }
        }))
        return result
    except Exception as e:
        print(f"Error: {e}")
        return None

# Check for assignments due in the next 7 days
days_ahead = 7
assignments = upcoming_assignments(days_ahead)

print(f"\n Upcoming assignments in the next {days_ahead} days: {len(assignments)}")
for a in assignments:
    print(f"- {a['title']} | Due: {a['dueDate']}")

# Task 4.2 - Aggregation Pipelines
#count total enroll per course
pipeline = [
    {"$group": {
        "_id": "$courseId",
        "totalEnrollments": {"$sum": 1}
    }},
    {"$sort": {"totalEnrollments": -1}}
]
result = list(enrollment_collection.aggregate(pipeline))
print(result)

#calculate average course rating
pipeline = [
    {"$match": {"rating": {"$exists": True}}},
    {"$group": {
        "_id": "$courseId",
        "averageRating": {"$avg": "$rating"}
    }},
    {"$sort": {"averageRating": -1}}
]
result = list(enrollment_collection.aggregate(pipeline))
print(result)

#group by course category
pipeline = [
    {"$group": {
        "_id": "$category",
        "courseCount": {"$sum": 1},
        "averagePrice": {"$avg": "$price"}
    }},
    {"$sort": {"courseCount": -1}}
]
result = list(course_collection.aggregate(pipeline))
print(result)
# student performance analysis
#average grade per student
pipeline = [
    {"$group": {
        "_id": "$studentId",
        "averageScore": {"$avg": "$score"},
        "submissionsCount": {"$sum": 1}
    }},
    {"$sort": {"averageScore": -1}}
]
result = list(submission_collection.aggregate(pipeline))
print(result)

#completion rate by course
pipeline = [
    {"$group": {
        "_id": "$courseId",
        "avgCompletionRate": {"$avg": "$progress"}
    }},
    {"$sort": {"avgCompletionRate": -1}}
]
result = list(enrollment_collection.aggregate(pipeline))
print(result)

# Top performing students
pipeline = [
    {"$group": {
        "_id": "$studentId",
        "avgScore": {"$avg": "$score"}
    }},
    {"$sort": {"avgScore": -1}},
    {"$limit": 5}
]
result = list(submission_collection.aggregate(pipeline))
print(result)

# instructor analysis
#Total students taught by each instructor
pipeline = [
    {
        "$lookup": {
            "from": "submission_collection",  # corrected name
            "localField": "assignmentId",
            "foreignField": "assignmentId",
            "as": "submissions"
        }
    },
    {"$unwind": "$submissions"},
    {
        "$group": {
            "_id": "$instructorId",  # fix: use instructorId not instructorName
            "uniqueStudents": {"$addToSet": "$submissions.studentId"}
        }
    },
    {
        "$project": {
            "instructorId": "$_id",
            "totalStudents": {"$size": "$uniqueStudents"}
        }
    },
    {"$sort": {"totalStudents": -1}}
]
result = list(assignment_collection.aggregate(pipeline))
print(result)
    
# average course rating per instructor

pipeline = [
    {
        "$group": {
            "_id": "$instructorName",
            "avgRating": {"$avg": "$rating"}
        }
    },
    {
        "$sort": {"avgRating": -1}
    }
]
result = list(course_collection.aggregate(pipeline))
print(result)

#revenue generated per instructor
pipeline = [
    {
        "$lookup": {
            "from": "course_collection",  # Make sure this is the correct name
            "localField": "courseId",
            "foreignField": "courseId",
            "as": "courseInfo"
        }
    },
    { "$unwind": "$courseInfo" },
    {
        "$group": {
            "_id": "$courseInfo.instructorName",
            "totalEnrollments": { "$sum": 1 },
            "totalRevenue": {
                "$sum": "$courseInfo.price"
            }
        }
    },
    {
        "$project": {
            "instructor": "$_id",
            "revenue": "$totalRevenue"
        }
    },
    { "$sort": { "revenue": -1 } }
]

result = list(db.enrollment_collection.aggregate(pipeline))
for r in result:
    print(f"Instructor: {r['instructor']} | Revenue: ${r['revenue']}")


#advanced analysis
#Monthly enrollment trends
pipeline = [
    {
        "$group": {
            "_id": {
                "year": { "$year": "$enrolledAt" },
                "month": { "$month": "$enrolledAt" }
            },
            "totalEnrollments": { "$sum": 1 }
        }
    },
    {
        "$sort": {
            "_id.year": 1,
            "_id.month": 1
        }
    }
]
result = list(enrollment_collection.aggregate(pipeline))
print(result)

#Most  popular course categories
pipeline = [
    {
        "$lookup": {
            "from": "course_collection",  # use your actual courses collection name
            "localField": "courseId",
            "foreignField": "courseId",
            "as": "courseInfo"
        }
    },
    {
        "$unwind": "$courseInfo"
    },
    {
        "$group": {
            "_id": "$courseInfo.category",
            "totalEnrollments": {"$sum": 1}
        }
    },
    {
        "$sort": {"totalEnrollments": -1}
    }
]

result = list(enrollment_collection.aggregate(pipeline))
print(result)

#Student engagement metrics
pipeline = [
    {
        "$group": {
            "_id": "$studentId",
            "submissionCount": { "$sum": 1 }
        }
    },
    {
        "$group": {
            "_id": None,
            "avgSubmissionsPerStudent": { "$avg": "$submissionCount" }
        }
    }
]
result = list(submission_collection.aggregate(pipeline))
print(result)

# Task 5.1 - Index Creation

users_collection.create_index("email", unique=True)
course_collection.create_index([("title", "text"), ("category", 1)])
assignment_collection.create_index("dueDate")
enrollment_collection.create_index([("studentId", 1), ("courseId", 1)])
# 1. User email lookup
users_collection.create_index("email", unique=True)
# 2. Course title and category search
course_collection.create_index([("title", "text")])
course_collection.create_index("category")

# 3. Assignment by due date
assignment_collection.create_index("dueDate")

# 4. Enrollment by student and course
enrollment_collection.create_index([("studentId", 1), ("courseId", 1)])

#Task 5.2 — Query Optimization
#slow query and optimization
#1("user search by email")
query = {"email": "lisa@example.com"}


import time

start = time.time()
users_collection.find_one(query)
end = time.time()

print("Query time without index:", end - start)
#optimization

users_collection.create_index("email", unique=True)
start = time.time()
users_collection.find_one(query)
end = time.time()

print("Query time with index:", end - start)

("course search by category")
#2
search_term = "python"
query = {
    "title": {"$regex": search_term, "$options": "i"}
}
import time

start = time.time()
courses = list(course_collection.find(query))
end = time.time()

print("Time before index:", end - start)

#optimization
course_collection.drop_index("title_text")

from pymongo import TEXT

course_collection.create_index([
    ("title", TEXT),
    ("category", TEXT)
])
course_collection.create_index([
    ("title", "text"),
    ("category", "text")
])
start = time.time()
courses = list(course_collection.find(query))
end = time.time()

print("Time after index:", end - start)

#3("assignment queries by duedate")
#slow
assignment_collection.create_index("dueDate")
import time

# Define date range
from datetime import datetime, timedelta
now = datetime.now()
next_week = now + timedelta(days=7)

# Start timing
start_time = time.time()
query = {
    "dueDate": {
        "$gte": now,
        "$lte": next_week
    }
}
result = list(assignment_collection.find(query))

# End timing
end_time = time.time()
#analysing query using the explain()
explain_result = users_collection.find(query).explain()#("user search by email")
print(explain_result)
explain_result = course_collection.find(query).explain()# course search by category
print(explain_result["queryPlanner"]["winningPlan"])
explain = assignment_collection.find(query).explain() # assignment queries by duedatea

print("Time taken:", end_time - start_time, "seconds")
print("Documents found:", len(result))
print("Explain plan:", explain["queryPlanner"]["winningPlan"])


#Task 6.1
db.create_collection("users_collection",
    validator= {
        
       
    "$jsonSchema": {
        "bsonType": "object",
        "required": ["userId", "email", "firstName", "lastName", "role", "dateJoined","profile", "isActive"],
        "properties": {
            "userId": {
                "bsonType": "string",
                "description": "must be a string and unique"
            },
            "email": {
                "bsonType": "string",
                "description": "must be a string and is required"
            },
            "firstName": {
                "bsonType": "string",
                "description": "must be a string and is required"
            },
            "lastName": {
                "bsonType": "string",
                "description": "must be a string and is required"
            },
            "role": {
                "bsonType": "string",
                "enum": ["student", "instructor"],
                "description": "can only be 'student' or 'instructor'"
            },
            "dateJoined": {"dateJoined"
                "bsonType": "date",
                "description": "must be a date"
            },
            "profile": {
                "bsonType": "object",
                "properties": {
                    "bio": {
                        "bsonType": "string"
                    },
                    "avatar": {
                        "bsonType": "string"
                    },
                    "skills": {
                        "bsonType": "array",
                        "items": {
                            "bsonType": "string"
                        }
                    }
                }
            },
            "isActive": {
                "bsonType": "bool",
                "description": "must be a boolean"
            }
        }
    }
})


# Task 6.2 - Error Handling
# Duplicate key
from pymongo.errors import DuplicateKeyError
from datetime import datetime, timezone
from pymongo.errors import DuplicateKeyError

try:
    users_collection.insert_one({
        "userId": "123",
        "email": "duplicate@example.com",
        "firstName": "John",
        "lastName": "Doe",
        "role": "student",
        "dateJoined": datetime.now(timezone.utc),
        "isActive": True,
        "profile": {}  # or provide actual profile data if needed
    })
except DuplicateKeyError:
    print("Duplicate email detected! Please use a different email.")
#2. Invalid Data Type
from datetime import datetime, timezone

try:
    course_collection.insert_one({
        "courseId": "course_10",
        "title": "Intro to Bugs",
        "description": "Learn to find and fix bugs",
        "instructorId": "instructor_123",
        "category": "Programming",
        "level": "beginner",  # lowercase to match enum
        "duration": 10,
        "price": 0,
        "tags": ["bugs", "debugging", "intro"],
        "isPublished": True,
        "createdAt": datetime.now(timezone.utc),  #  timezone-aware
        "updatedAt": datetime.now(timezone.utc)
    })
except Exception as e:
    print("Invalid data type error:", e)


# Missing required field
#3. Missing Required Fields
from datetime import datetime, timezone

try:
    users_collection.insert_one({
        "userId": "456",
        "email": "jane@example.com",  # required
        "firstName": "Jane",
        "lastName": "Smith",          # required
        "role": "instructor",
        "dateJoined": datetime.now(timezone.utc),  # required
        "isActive": True,             # required
        "profile": {
            "bio": "Experienced instructor.",
            "social": {
                "twitter": "@jane_doe"
            }
        }  # required nested field
    })
    print("User inserted successfully.")
except Exception as e:
    print("Missing required field:", e)